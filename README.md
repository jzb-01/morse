# Continues Online Wave (C.O.W)
#### Video Demo: https://youtu.be/szzkuMdqhXI
#### Description (everything below)
C.O.W (Continues Online Wave) is an interactive web application i designed to help people learn Morse code. It provides both informative content about Morse code and interactive tools to practice and test oneself. Users can listen to Morse code sounds, decode fictional messages, translate text into Morse code, and train using a method inspired by the Koch method. Additionally, users can create accounts to save notes and publish messages using a virtual telegraph.
#### Technologies Used
- Backend: Python (Flask framework)
- Frontend: HTML, CSS, JavaScript
- Database: SQLite (SQL for data management)
#### File Structure
This project follows a typical Flask application structure. The core logic resides in `app.py`, which manages the application's routes. The `static/` folder contains all client-side assets, organized into `css/` with `styles.css`; `js/`, which includes JavaScript files such as `blackbox.js`, `code.js`, `data.js`, `functions.js`, `message.js`, `notes.js`, `telegraph.js`, `training.js`, and `translator.js`; and `images/`, featuring cow-themed visuals like `account_cow.jpeg`, `code_cow.jpeg`, `cowprint.jpg`, `failed_cow.jpeg`, `failure_cow.jpeg`, `finish_cow.jpeg`, `index_cow.jpg`, `logged_cow.jpeg`, `morse_cow.jpeg`, `passed_cow.jpeg`, and `succes_cow.jpeg`. The `templates/` folder contains all HTML files used for rendering views, including `account.html`, `archives.html`, `blackbox.html`, `code.html`, `failure.html`, `index.html`, `layout.html`, `message.html`, `morse.html`, `notes.html`, `success.html`, `telegraph.html`, `training.html`, and `translator.html`. Additionally, `morse.db` is the SQLite database used by the application, and `requirements.txt` lists the project's dependencies.

#### Backend Overview
**How app.py Works?**  
The core of the application is `app.py`. The file ties together various features and routes into one cohesive Flask web app. At the top, it imports essential modules: Flask for handling web requests, Flask-Session for managing sessions, and CS50’s SQL module to interact with an SQLite database named `morse.db`. It also imports werkzeug.security for password hashing and the re module to validate email addresses. The app is configured to store sessions on the filesystem.  
A routless function defined in `app.py` is is_valid_email(). This function uses a regular expression to ensure that any email entered by the user matches a basic valid format. Following the initial setup, app.py sets up a series of routes that handle both page rendering and data processing. While routes like /, /morse, and /code simply render their respective HTML templates, more complex routes handle data operations. For example, the /archives route lets users select and view archived stories, while the /notes and /blackbox routes manage the retrieval and display of user notes and logs.
#### Database Overview
**How morse.db Works?**  
The application uses a database named `morse.db` that is structured to store user’s information, notes, logs, and stories. The database consists of four tables:
- **Users:** This table is the foundation for user registration and stores essential information for each user. It includes a unique id (primary key), a username, and an email—both of which must be unique to prevent duplicates. Passwords are securely stored as hashes, and a created_at timestamp automatically records when the user registers.
- **Notes:** Designed for saving user-generated content, each note is linked to a specific user through a user_id foreign key. The content field holds the text of the note, while the created_at timestamp records when it was added. The table is designed with a cascading delete rule, so if a user is removed, all associated notes are also deleted.
- **Logs:** This table stores public comments made by the users (which i decided to call logs). Like the Notes table, it is linked to individual users via the user_id foreign key. The log_message field contains the user comment, and the created_at timestamp the date it was shared. This table also supports cascading deletion to maintain data integrity.
- **Stories:** Unlike the other tables, the Stories table is independent of user accounts. It stores standalone stories with a unique id, a title, and the story_content field, allowing stories to be accessed by multiple users without direct linkage to a specific user account.

#### Frontend Structure and Styling
**Layout Template: The Backbone of the App**  
The layout.html file serves as the main layout template for the entire web app. This file is structured as a full HTML document, with a head section that sets up the page’s meta information, links stylesheets and Font Awesome icons, and includes a dynamic title tag through the {% block title %} placeholder. Additionally, a JavaScript block ({% block js %}) is available for including page-specific scripts.
The body of layout.html is divided into three main parts. At the top is the header, which features a fixed navigation bar linking to key sections of the app such as C.O.W (home), Morse, Code, Archives, Notes, Blackbox, and Account. The main content area, defined by the main tag and the {% block main %} placeholder, is where page-specific content is injected. At the bottom, a footer provides additional navigation links to tools like Translator, Telegraph, and Training, ensuring that users can easily access these interactive features from any page.  
**CSS Styling Overview**  
The CSS file for the app defines the overall visual style and layout. The background is set to display a cowprint image (created by me), which remains fixed and covers the entire viewport. The header and footer are fixed at the top and bottom of the screen, respectively, ensuring that navigation links are always visible. Both elements have a black background, with links that change to a white background and black text on hover—providing clear visual feedback.
The main content area is carefully positioned between the header and footer so that content never overlaps the navigation elements. Tables within this area are formatted with evenly spaced cells and centered text, with collapsed borders for a clean look. Specific content boxes, such as .archive_box and.settings_box provide structure and visual distinction across different sections. Buttons are styled with large fonts and hover effects, making interactions easy and intuitive.

#### Landing, Information, and Feedback Pages  
**Landing and Information Pages**  
The landing section of the app is composed of two complementary pages that welcome and inform users about the platform and Morse code itself.  
- **Home Page (index.html):**
This page serves as the gateway to C.O.W, introducing the platform as an all-in-one Morse code companion. The information box on the left details the main functionalities: translation between text and Morse code, realistic telegraph practice, and Koch-like method training for step-by-step learning. It also emphasizes the benefits of registering—such as saving notes and sharing messages with the community.
- **Morse Overview Page (morse.html):**
While the Home page introduces the platform, the Morse overview page delves deeper into the subject of Morse code. It explains the basics of Morse code—the system of dots and dashes invented in the 1830s—and its historical importance in communication, emergencies, and navigation. This page covers common uses of Morse code, such as distress signaling and radio communication, and discusses its practical benefits, like sharpening memory and preparing for emergencies. On the backend, the Python routes / and /morse simply render index.html and morse.html respectively.


#### Feedback Pages: Success and Failure
To provide clear responses based on user actions, the app includes dedicated feedback pages.
- **Success Page (success.html):**
When an action is completed successfully, the success page celebrates the achievement with a header that says "Cow-abunga!" and an image of a happy cow. A large alert message (populated dynamically via the {{alert}} variable) offers detailed feedback on what was successful.
- **Failure Page (failure.html):**
If an error occurs or something doesn’t go as planned, the failure page provides feedback. Its header, "Moo-ps!", uses similar styling to signal an error accompanied by a sad cow image. The page explains the problem via a prominent alert message (using {{alert}}), ensuring that users understand what went wrong.

#### Feature Modules
- **Code Feature:**
The Code feature is centered on code.html, which extends the layout template to ensure consistency. This page allows users to switch between different Morse code tables—letters, numbers, and symbols—each accompanied by a play button to hear the corresponding Morse sounds. A cow image adds to the design, and a slider at the bottom controls the speed of Morse code playback. The interactive functionality is handled by code.js, which imports the beep and delay functions from functions.js to generate Morse code sounds using the Web Audio API. When users switch tables, the display updates so that only one table is visible at a time, and the slider value adjusts the duration of the Morse code beeps.
- **Archives Feature:**
The Archives feature enables users to browse a collection of stories. The archives.html page arranges these stories in a neat grid layout. Each archive box features a title (such as "Secret Agent Mission Briefing" or "Alien Communication"), a brief description, and a button that, when clicked, sends the story's ID to the server via a form. On the server side, the /archives route processes the request, looks up the story in the database, and, if found, renders the message.html template with the story’s title and content. The message.html page then displays the full story in a well-styled box along with controls for playing the story in Morse code. This interactive playback is managed by message.js, which uses functions from functions.js to generate the appropriate sounds based on a slider-controlled playback speed.
- **Notes Feature:**
The Notes feature is presented through notes.html, which also extends layout.html. This page includes a dropdown menu for selecting saved notes and displays the content of the selected note along with its creation timestamp. If there are no saved notes, a message informs the user accordingly. Below the display area, buttons allow users to play, stop, or restart the Morse code playback of their notes, and a slider adjusts the playback speed. The interactive elements are managed by notes.js, which listens for changes in the dropdown selection and slider adjustments. On the backend, the /notes route in Python retrieves the appropriate notes for the logged-in user and passes them to notes.html for display.
- **Blackbox Feature:**
The Blackbox feature is quite similar to the Notes feature but focuses on logs rather than notes. The blackbox.html file uses the common base template and features a reversed gradient background to differentiate its design. On this page, users select logs from a dropdown menu, and upon selection, the log’s content is displayed along with details such as the author and creation time. The page includes playback controls—play, stop, and restart—as well as a slider to adjust the time unit for Morse code sound duration. The functionality is handled by blackbox.js, which uses the same imported functions (beep and delay) from functions.js to produce sound. The backend route /blackbox validates user input and fetches log details from the database before rendering the template.
- **Account Management Feature:**
The account page, account.html, serves dual purposes depending on the user’s login status. If a user is logged in, the page displays their personal details (username, email, account creation date) along with a prominent “Log Out” button. The information is neatly arranged alongside a cow image. If the user is not logged in, two separate forms are provided for signing up and signing in. The sign-up form collects email, username, and password (with confirmation), while the sign-in form requires only email and password. On the backend, the /account route checks the session to determine whether to display the logged-in view or the forms. Additional routes—/signup, /signin, and /logout—handle account creation, user authentication, and session termination, respectively.
- **Translator Feature:**
The Translator feature provides a straightforward interface for converting plain text into Morse code and vice versa. The translator.html page extends layout.html and sets up two side-by-side text areas: one for entering regular text and one for displaying its Morse code translation. A title at the top clearly marks the page as "Translator," and a control section at the bottom includes play and stop buttons alongside a slider to adjust the time unit for playback. translator.js ties everything together by importing translation dictionaries from data.js (for both text-to-Morse and Morse-to-text conversion) and functions from functions.js to produce the Morse code sounds. As you type, the script listens for input and converts the text on the fly, handling line breaks and unknown characters. The backend for this feature is straightforward—the /translator route simply renders the translator page.
- **Telegraph Feature:**
The Telegraph feature is designed to mimic the experience of sending messages via a classic telegraph system, complete with timing-based input. The telegraph.html file extends the base template and prominently displays a title labeled “Telegraph.” The main interface features a large, read-only textarea where your message appears as you “type” it using the spacebar. Depending on your login status, additional buttons allow you to either save your message to your notes or publish it to the public blackbox. A telegraph button at the bottom, along with info, settings, and clear buttons, helps control the process, while an on-screen timer in the bottom right corner shows how long the spacebar is pressed or not—a crucial detail for determining whether you’re sending a dot, dash, or space. The interactive behavior is managed by telegraph.js, which also displays pop-up windows for extra information and timing settings adjustments. This type of settings allows the user to customize the base time unit for a dot, and also fine-tune the margins for what counts as a dot versus a dash, as well as the spaces between letters and words. This flexibility ensures that the telegraph can accommodate different tapping rhythms, making it more forgiving and tailored to different users. On the backend, the /telegraph route processes the submitted message by checking if the user is logged in and then distinguishing between a save or publish action. If there’s an issue (such as no message or a missing login), the route redirects to a failure page with a helpful alert.
- **Training Feature:**
The Training module is designed to help users practice decoding Morse code through an interactive, audio-based exercise. The training.html file sets up the interface by extending the common layout and includes buttons for settings and information, as well as a clear header labeled "Training." In the main area, you’ll see a display of characters that you’ll be working with, a text area where you can type what you hear, and control buttons for starting, stopping, restarting, and evaluating your performance. A status indicator shows the number of beeps played and the current training level. The heavy lifting is done by training.js, which imports the Morse code dictionary and helper functions (such as beep, delay, and checkls) from data.js and functions.js. When you press the start button, the script shuffles the character list and plays a series of Morse code signals via the Web Audio API, with playback speed controlled by an adjustable “time unit.” As you listen, you type the characters, and when the session ends, you can evaluate your performance, with the module comparing your input against the played sequence and providing an accuracy report where you can decide if you want to continue and add another character to the practice, restart the set or quit. The backend route /training simply renders the training page.

#### Data & Functions Modules
The functionality of the app is further enhanced by two dedicated JavaScript modules:
- **data.js:** acts as a central repository for all Morse code mappings and character lists. It defines a dictionary that maps letters, numbers, and various symbols to their Morse code representations and also provides a reverse dictionary for converting Morse code back to text. In addition, it includes arrays for the alphabet, numbers, and a collection of special characters. This ensures that every module within the app uses a consistent set of characters.
- **functions.js:** contains the utility functions that drive interactivity. The beep function generates a clear sine-wave beep using the Web Audio API, which forms the basis of all Morse code playback in the project. The delay function creates a pause using Promises—essential for timing the beeps correctly between dots and dashes. Finally, the checkls function listens for changes in checkbox inputs (such as whether to include the alphabet, numbers, or special characters in the training feature) and updates the displayed list accordingly, ensuring that your practice sessions always include the desired characters.

